// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 2.4.13.
// **********************************************************************

#ifndef __COMSHARE_H_
#define __COMSHARE_H_

#include <map>
#include <string>
#include <vector>
#include "tup/Tars.h"
#include "tup/TarsJson.h"
using namespace std;


namespace sole
{
    struct Data : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "sole.Data";
        }
        static string MD5()
        {
            return "bc0712e4b3abda8a82f5be6808d0fc70";
        }
        Data()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            id = 0;
            type = "";
            sV = "";
            dV = 0;
            nV = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(id, 1);
            _os.write(type, 2);
            if (v.size() > 0)
            {
                _os.write(v, 3);
            }
            if (m.size() > 0)
            {
                _os.write(m, 4);
            }
            if (sV != "")
            {
                _os.write(sV, 5);
            }
            if (dV != 0)
            {
                _os.write(dV, 6);
            }
            if (nV != 0)
            {
                _os.write(nV, 7);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(id, 1, true);
            _is.read(type, 2, true);
            _is.read(v, 3, false);
            _is.read(m, 4, false);
            _is.read(sV, 5, false);
            _is.read(dV, 6, false);
            _is.read(nV, 7, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["id"] = tars::JsonOutput::writeJson(id);
            p->value["type"] = tars::JsonOutput::writeJson(type);
            p->value["v"] = tars::JsonOutput::writeJson(v);
            p->value["m"] = tars::JsonOutput::writeJson(m);
            p->value["sV"] = tars::JsonOutput::writeJson(sV);
            p->value["dV"] = tars::JsonOutput::writeJson(dV);
            p->value["nV"] = tars::JsonOutput::writeJson(nV);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(id,pObj->value["id"], true);
            tars::JsonInput::readJson(type,pObj->value["type"], true);
            tars::JsonInput::readJson(v,pObj->value["v"], false);
            tars::JsonInput::readJson(m,pObj->value["m"], false);
            tars::JsonInput::readJson(sV,pObj->value["sV"], false);
            tars::JsonInput::readJson(dV,pObj->value["dV"], false);
            tars::JsonInput::readJson(nV,pObj->value["nV"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(id,"id");
            _ds.display(type,"type");
            _ds.display(v,"v");
            _ds.display(m,"m");
            _ds.display(sV,"sV");
            _ds.display(dV,"dV");
            _ds.display(nV,"nV");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(id, true);
            _ds.displaySimple(type, true);
            _ds.displaySimple(v, true);
            _ds.displaySimple(m, true);
            _ds.displaySimple(sV, true);
            _ds.displaySimple(dV, true);
            _ds.displaySimple(nV, false);
            return _os;
        }
    public:
        tars::Int64 id;
        std::string type;
        vector<sole::Data> v;
        map<std::string, sole::Data> m;
        std::string sV;
        tars::Double dV;
        tars::Int64 nV;
    };
    inline bool operator==(const Data&l, const Data&r)
    {
        return l.id == r.id && l.type == r.type && l.v == r.v && l.m == r.m && l.sV == r.sV && l.dV == r.dV && l.nV == r.nV;
    }
    inline bool operator!=(const Data&l, const Data&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const Data&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,Data&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }

    struct Event : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "sole.Event";
        }
        static string MD5()
        {
            return "6e0dfec8c2a032afa3773adbd2cde27a";
        }
        Event()
        {
            resetDefautlt();
        }
        void resetDefautlt()
        {
            id = 0;
            type = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(id, 1);
            _os.write(type, 2);
            _os.write(w, 3);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(id, 1, true);
            _is.read(type, 2, true);
            _is.read(w, 3, true);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["id"] = tars::JsonOutput::writeJson(id);
            p->value["type"] = tars::JsonOutput::writeJson(type);
            p->value["w"] = tars::JsonOutput::writeJson(w);
            return p;
        }
        string writeToJsonString() const
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(id,pObj->value["id"], true);
            tars::JsonInput::readJson(type,pObj->value["type"], true);
            tars::JsonInput::readJson(w,pObj->value["w"], true);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(id,"id");
            _ds.display(type,"type");
            _ds.display(w,"w");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(id, true);
            _ds.displaySimple(type, true);
            _ds.displaySimple(w, false);
            return _os;
        }
    public:
        tars::Int64 id;
        std::string type;
        sole::Data w;
    };
    inline bool operator==(const Event&l, const Event&r)
    {
        return l.id == r.id && l.type == r.type && l.w == r.w;
    }
    inline bool operator!=(const Event&l, const Event&r)
    {
        return !(l == r);
    }
    inline ostream& operator<<(ostream & os,const Event&r)
    {
        os << r.writeToJsonString();
        return os;
    }
    inline istream& operator>>(istream& is,Event&l)
    {
        std::istreambuf_iterator<char> eos;
        std::string s(std::istreambuf_iterator<char>(is), eos);
        l.readFromJsonString(s);
        return is;
    }


}



#endif
